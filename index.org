#+TITLE: An Introduction to Monoids
#+OPTIONS: toc:1, num:nil, timestamp:nil, \n:t
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@3.8.0
#+REVEAL_THEME: moon
#+REVEAL_EXTRA_CSS: ./css/monoid.css

* Outline
* Examples

** Example: Shipping Packages
Let's say I have a bunch of packages that need to be shipped.
#+BEGIN_SRC python
packages = [{'destination': '968 East Summit Court New Lenox, IL 60451',
             'description': 'Marbles\n'
                  'weight': 13},
            {'destination': '75 South George Street Muskegon, MI 49441',
             'description': 'Medical supplies\n'
                  'weight': 5},
            {'destination': '238 N. Holly Ave. Tampa, FL 33604',
             'description': 'Frisbees\n'
                  'weight': 4}]
#+END_SRC

** Total Weight

In order to ship I need to calculate their total weight.

#+ATTR_REVEAL: :frag (appear)
#+HEADER: :exports both
#+BEGIN_SRC python :results value pp
totalWeight = 0
for package in packages:
  totalWeight += package['weight']
#+END_SRC

#+RESULTS:

#+ATTR_REVEAL: :frag (appear)
But let's do it a little more functionally:
#+ATTR_REVEAL: :frag (appear)
#+BEGIN_SRC python
weights = [package['weight'] for package in packages]

totalWeight = reduce(operator.add, weights, 0)
#+END_SRC
#+ATTR_REVEAL: :frag (appear)
#+BEGIN_SRC python
# Haskell type signature
# reduce :: (b -> a -> b) -> [a] -> b -> b
#+END_SRC

** Reducing/Folding
[[file:img/Left-fold-transformation.png]]

#+ATTR_REVEAL: :frag (appear)
#+BEGIN_SRC python
weights = [13, 5, 4] # 13 : 5 : 4 : []
#+END_SRC
#+ATTR_REVEAL: :frag (appear)
#+BEGIN_BLOCK
If we replace ~f~ in the diagram with ~add~ and ~z~ with ~0~, we get:
#+BEGIN_SRC python
totalWeight = add(add(add(0, 13), 5), 4)
#+END_SRC
#+END_BLOCK

** Any Over 10?
The shipping company charges extra if our shipment contains any package over 10.
#+BEGIN_SRC python
overTwelve = [weight > 10 for weight in weights]
         # = [True, False, False]
anyOverTwelve = reduce(operator.or, overTwelve, False)
            # = True
#+END_SRC

** All Under 15?
But they give a rebate if all packages are under 10
(just go with it).
#+BEGIN_SRC python
underTen = [weight < 10 for weight in weights]
       # = [False, True, True]
allUnderTen = reduce(operator.and, underTen, True)
          # = False
#+END_SRC

** Construct a Manifest
Let it just be the concatentation of all the package descriptions.
#+BEGIN_SRC python
descriptions = [package['description'] for package in packages]
manifest = reduce(operator.add, descriptions, "")
       # = 'Marbles
       #    Medical Supplies
       #    Frisbees'
#+END_SRC

* A Pattern

** Let's Summarize Those Examples

| Objective           | Code                                    |
|---------------------+-----------------------------------------|
| Sum Integers        | reduce(operator.add, listOfInts, 0)     |
| Check if any True   | reduce(operator.or, listOfBools, False) |
| Check if all True   | reduce(operator.and, listOfBools, True) |
| Concatenate Strings | reduce(operator.add, listOfStrings, "") |

** Two Things to Notice
#+ATTR_REVEAL: :frag (appear)
1. They differ only in the operator being used and the initial value.
2. The type of the initial value is the same as the list elements.  Therefore the type of ~reduce~ is /specialized/ from this:

        #+BEGIN_SRC haskell
        reduce :: (b -> a -> b) -> [a] -> b -> b
        #+END_SRC

    to this:

        #+BEGIN_SRC haskell
        reduce :: (a -> a -> a) -> [a] -> a -> a
        #+END_SRC

** A New Perspective
This specialized type has a new interpretation.  The former /reducing/ function can be thought of as a /combining/ function: it combines two values of the same type.

* Abstraction

** Semigroups

Data types that have such a binary operator are known as [[https://en.wikipedia.org/wiki/Semigroup][~Semigroups~]].

** But There's Just One More Thing
#+ATTR_REVEAL: :frag (appear)
To be a valid ~Semigroup~ you can't have just any old combining function; it must be /associative/.
#+ATTR_REVEAL: :frag (appear)
#+BEGIN_BLOCK
If the combining function is denoted by ~<>~, then associativity requires:
#+BEGIN_SRC haskell
(a <> b) <> c == a <> (b <> c)
#+END_SRC
#+END_BLOCK

** Monoids
A [[https://en.wikipedia.org/wiki/Monoid][~Monoid~]] is a ~Semigroup~ that has a
/distinguished element/.
#+ATTR_REVEAL: :frag (appear)
This element is also referred to as an /identity/ element or /unit/.
#+ATTR_REVEAL: :frag (appear)
In our examples the initial value is actually the identity element for each case.

** Monoid Instances
| Type    | Operation     | Identity |
|---------+---------------+----------|
| Int     | Plus          | 0        |
| Int     | Multiply      | 1        |
| String  | Concatenation | ""       |
| List    | Concatenation | []       |
| Boolean | And           | True     |
| Boolean | Or            | False    |
And many more!

* Conclusion
